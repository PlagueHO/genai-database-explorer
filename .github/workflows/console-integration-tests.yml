name: Console App Integration Tests

on:
  workflow_call:
    inputs:
      ENVIRONMENT:
        description: "The environment to use for integration testing"
        required: true
        type: string
      RESOURCE_GROUP_NAME:
        description: "The Azure resource group name containing the SQL Server"
        required: true
        type: string
      SQL_SERVER_NAME:
        description: "The SQL Server name for database connection"
        required: true
        type: string
      AZURE_AI_FOUNDRY_ENDPOINT:
        description: "The Azure AI Foundry endpoint for AI operations"
        required: false
        type: string
      AZURE_AI_FOUNDRY_NAME:
        description: "The Azure AI Foundry resource name for endpoint construction"
        required: false
        type: string

    secrets:
      SQL_SERVER_USERNAME:
        description: "The SQL Server username for the application"
        required: true
      SQL_SERVER_PASSWORD:
        description: "The SQL Server password for the application"
        required: true
      AZURE_CLIENT_ID:
        description: "Azure service principal client ID for authentication"
        required: true
      AZURE_TENANT_ID:
        description: "Azure tenant ID for authentication"
        required: true
      AZURE_SUBSCRIPTION_ID:
        description: "Azure subscription ID for resource access"
        required: true

jobs:
  console-app-integration-tests:
    name: Console App Integration Tests
    runs-on: ubuntu-latest
    environment: ${{ inputs.ENVIRONMENT }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Download Console App Artifact
        uses: actions/download-artifact@v4
        with:
          name: console-app-published
          path: ./publish

      - name: Make Console App Executable
        run: chmod +x ./publish/GenAIDBExplorer.Console

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true

      - name: Configure SQL Server Firewall for GitHub Runner
        uses: azure/powershell@v2
        with:
          azPSVersion: "latest"
          inlineScript: |
            # Get the current runner's public IP address
            $RunnerIP = (Invoke-RestMethod -Uri "https://ipinfo.io/ip" -Method Get).Trim()
            Write-Host "GitHub Runner IP: $RunnerIP"
            
            # Use the provided resource group and SQL server names
            $SqlServerName = "${{ inputs.SQL_SERVER_NAME }}"
            $ResourceGroup = "${{ inputs.RESOURCE_GROUP_NAME }}"
            $FirewallRuleName = "GitHubRunner-${{ github.run_id }}"
            
            Write-Host "Adding firewall rule for SQL Server: $SqlServerName"
            Write-Host "Resource Group: $ResourceGroup"
            Write-Host "Runner IP: $RunnerIP"
            Write-Host "Firewall Rule Name: $FirewallRuleName"
            
            try {
              # Add firewall rule for the GitHub runner IP
              New-AzSqlServerFirewallRule `
                -ResourceGroupName $ResourceGroup `
                -ServerName $SqlServerName `
                -FirewallRuleName $FirewallRuleName `
                -StartIpAddress $RunnerIP `
                -EndIpAddress $RunnerIP
              
              Write-Host "✅ Firewall rule created successfully" -ForegroundColor Green
            }
            catch {
              Write-Error "Failed to create firewall rule: $($_.Exception.Message)"
              throw
            }

      - name: Enable Azure AI Foundry Public Access for Integration Tests
        uses: azure/powershell@v2
        with:
          azPSVersion: "latest"
          inlineScript: |
            # Extract environment suffix from SQL server name for AI Foundry service name
            $SqlServerName = "${{ inputs.SQL_SERVER_NAME }}"
            $ResourceGroup = "${{ inputs.RESOURCE_GROUP_NAME }}"
            
            # Try to construct AI Foundry service name from SQL server pattern
            if ($SqlServerName -match '^sql-(.+)$') {
              $EnvSuffix = $matches[1]
              $AIFoundryName = "aif-$EnvSuffix"
              Write-Host "Constructed AI Foundry service name: $AIFoundryName"
              
              # Check if the AI Foundry service exists
              Write-Host "Checking if AI Foundry service exists: $AIFoundryName"
              try {
                $account = Get-AzCognitiveServicesAccount -ResourceGroupName $ResourceGroup -Name $AIFoundryName -ErrorAction Stop
                Write-Host "Found AI Foundry service: $AIFoundryName"
                
                # Check current network configuration
                Write-Host "Checking current network configuration for AI Foundry service: $AIFoundryName"
                Write-Host "Current public network access: $($account.Properties.PublicNetworkAccess)"
                Write-Host "Current network ACLs default action: $($account.Properties.NetworkAcls.DefaultAction)"
                
                # Always update to ensure public access is enabled
                Write-Host "Setting public network access to Enabled for AI Foundry service: $AIFoundryName"
                
                # Create a network rule set that allows all access
                $networkRuleSet = New-Object Microsoft.Azure.Commands.Management.CognitiveServices.Models.PSNetworkRuleSet
                $networkRuleSet.DefaultAction = "Allow"
                
                Set-AzCognitiveServicesAccount `
                  -ResourceGroupName $ResourceGroup `
                  -Name $AIFoundryName `
                  -PublicNetworkAccess "Enabled" `
                  -NetworkRuleSet $networkRuleSet `
                  -Force
                
                # Wait a moment for the change to propagate
                Write-Host "Waiting 10 seconds for network configuration to propagate..."
                Start-Sleep -Seconds 10
                
                # Verify the changes took effect
                $updatedAccount = Get-AzCognitiveServicesAccount -ResourceGroupName $ResourceGroup -Name $AIFoundryName
                Write-Host "Updated public network access: $($updatedAccount.Properties.PublicNetworkAccess)"
                Write-Host "Updated network ACLs default action: $($updatedAccount.Properties.NetworkAcls.DefaultAction)"
                
                if ($updatedAccount.Properties.PublicNetworkAccess -eq "Enabled" -and $updatedAccount.Properties.NetworkAcls.DefaultAction -eq "Allow") {
                  Write-Host "✅ Public network access successfully enabled for AI Foundry service" -ForegroundColor Green
                } else {
                  Write-Warning "⚠️  Network access may not have been properly updated."
                  Write-Host "   Expected: PublicNetworkAccess=Enabled, DefaultAction=Allow" -ForegroundColor Yellow
                  Write-Host "   Actual: PublicNetworkAccess=$($updatedAccount.Properties.PublicNetworkAccess), DefaultAction=$($updatedAccount.Properties.NetworkAcls.DefaultAction)" -ForegroundColor Yellow
                }
                
                # Set environment variable for cleanup step
                "AI_FOUNDRY_NAME=$AIFoundryName" | Out-File -FilePath $env:GITHUB_ENV -Append
              }
              catch {
                Write-Warning "Could not find AI Foundry service: $AIFoundryName"
                Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
                Write-Host "AI Foundry public access will not be modified"
              }
            }
            else {
              Write-Warning "Could not parse SQL server name pattern to construct AI Foundry service name"
              Write-Host "Expected format: sql-<environment-suffix>, got: $SqlServerName" -ForegroundColor Yellow
              Write-Host "AI Foundry public access will not be modified"
            }

      - name: Get Azure OpenAI API Key
        uses: azure/powershell@v2
        with:
          azPSVersion: "latest"
          inlineScript: |
            # Use the AI Foundry service name from the previous step
            $AIFoundryName = $env:AI_FOUNDRY_NAME
            if ($AIFoundryName) {
              $ResourceGroup = "${{ inputs.RESOURCE_GROUP_NAME }}"
              
              try {
                # Get Azure OpenAI API key from Cognitive Services
                Write-Host "Retrieving Azure OpenAI API key from AI Foundry service: $AIFoundryName"
                $keys = Get-AzCognitiveServicesAccountKey -ResourceGroupName $ResourceGroup -Name $AIFoundryName
                
                if ($keys.Key1) {
                  Write-Host "Azure OpenAI API key retrieved successfully"
                  "AZURE_OPENAI_API_KEY=$($keys.Key1)" | Out-File -FilePath $env:GITHUB_ENV -Append
                } else {
                  Write-Warning "Could not retrieve Azure OpenAI API key from service: $AIFoundryName"
                  Write-Host "AI-related integration tests may fail or be skipped"
                }
              }
              catch {
                Write-Warning "Could not retrieve Azure OpenAI API key from service: $AIFoundryName"
                Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
                Write-Host "AI-related integration tests may fail or be skipped"
              }
            }
            else {
              Write-Warning "No AI Foundry service name available from previous step"
              Write-Host "AI-related integration tests may fail or be skipped"
            }

      - name: Setup PowerShell and Run Console Integration Tests
        shell: pwsh
        env:
          SQL_CONNECTION_STRING: "Server=${{ inputs.SQL_SERVER_NAME }}.database.windows.net;Database=AdventureWorksLT;User Id=${{ secrets.SQL_SERVER_USERNAME }};Password=${{ secrets.SQL_SERVER_PASSWORD }};Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
          AZURE_OPENAI_ENDPOINT: ${{ inputs.AZURE_AI_FOUNDRY_ENDPOINT }}
          AZURE_OPENAI_API_KEY: ${{ env.AZURE_OPENAI_API_KEY }}
          CONSOLE_APP_PATH: ./publish/GenAIDBExplorer.Console
        run: |
          # Install and import Pester in the same session
          Write-Host "Installing and importing Pester module..." -ForegroundColor Yellow
          Install-Module -Name Pester -Force -Scope CurrentUser -MinimumVersion 5.7.1 -AllowClobber
          Import-Module Pester -Force -PassThru

          # Verify Pester is loaded
          $pesterVersion = Get-Module Pester | Select-Object -ExpandProperty Version
          Write-Host "Pester version loaded: $pesterVersion" -ForegroundColor Green

          # Debug environment variables
          Write-Host "=== Environment Variables Debug ===" -ForegroundColor Magenta
          Write-Host "SQL_CONNECTION_STRING: $($env:SQL_CONNECTION_STRING.Length) characters" -ForegroundColor Yellow
          Write-Host "AZURE_OPENAI_ENDPOINT: '$env:AZURE_OPENAI_ENDPOINT'" -ForegroundColor Yellow
          Write-Host "AZURE_OPENAI_API_KEY: $($env:AZURE_OPENAI_API_KEY.Length) characters (masked)" -ForegroundColor Yellow
          Write-Host "Input AZURE_AI_FOUNDRY_ENDPOINT: '${{ inputs.AZURE_AI_FOUNDRY_ENDPOINT }}'" -ForegroundColor Yellow
          Write-Host "Input AZURE_AI_FOUNDRY_NAME: '${{ inputs.AZURE_AI_FOUNDRY_NAME }}'" -ForegroundColor Yellow

          # Construct OpenAI endpoint if not provided but name is available
          if ([string]::IsNullOrEmpty($env:AZURE_OPENAI_ENDPOINT) -and -not [string]::IsNullOrEmpty('${{ inputs.AZURE_AI_FOUNDRY_NAME }}')) {
            $constructedEndpoint = "https://${{ inputs.AZURE_AI_FOUNDRY_NAME }}.cognitiveservices.azure.com/"
            Write-Host "Constructing OpenAI endpoint from AI Foundry name: $constructedEndpoint" -ForegroundColor Cyan
            $env:AZURE_OPENAI_ENDPOINT = $constructedEndpoint
          }

          # If we still don't have an endpoint and we know the SQL server name, try to construct from that pattern
          if ([string]::IsNullOrEmpty($env:AZURE_OPENAI_ENDPOINT) -and -not [string]::IsNullOrEmpty('${{ inputs.SQL_SERVER_NAME }}')) {
            # Extract the environment suffix from SQL server name (e.g., sql-gaidbexp-16461932142 -> gaidbexp-16461932142)
            $sqlServerName = '${{ inputs.SQL_SERVER_NAME }}'
            if ($sqlServerName -match '^sql-(.+)$') {
              $envSuffix = $matches[1]
              $constructedEndpoint = "https://$envSuffix.cognitiveservices.azure.com/"
              Write-Host "Constructing OpenAI endpoint from SQL server pattern: $constructedEndpoint" -ForegroundColor Yellow
              $env:AZURE_OPENAI_ENDPOINT = $constructedEndpoint
            }
          }

          # Check if endpoint and API key are available for AI tests
          if ([string]::IsNullOrEmpty($env:AZURE_OPENAI_ENDPOINT) -or [string]::IsNullOrEmpty($env:AZURE_OPENAI_API_KEY)) {
            Write-Warning "Azure AI Foundry endpoint or API key not available. AI-related integration tests will be skipped or may fail gracefully."
            Write-Host "This is expected behavior when AI services are not deployed or configured." -ForegroundColor Yellow
            Write-Host "To enable AI tests, ensure AZURE_AI_FOUNDRY_ENDPOINT is passed correctly from infrastructure provisioning." -ForegroundColor Yellow
            Write-Host "Check the 'Get Output Endpoints' step in provision-infrastructure workflow for Azure CLI endpoint retrieval." -ForegroundColor Yellow
            if ([string]::IsNullOrEmpty($env:AZURE_OPENAI_API_KEY)) {
              Write-Host "API key was not retrieved - check that the AI Foundry service exists and has the expected naming pattern." -ForegroundColor Yellow
            }
          } else {
            Write-Host "Azure AI services configured with endpoint and API key. AI integration tests will run." -ForegroundColor Green
            Write-Host "Endpoint format: $($env:AZURE_OPENAI_ENDPOINT)" -ForegroundColor Cyan

            # Validate endpoint format
            if ($env:AZURE_OPENAI_ENDPOINT -match 'https://.*\.cognitiveservices\.azure\.com/?$') {
              Write-Host "✅ Valid Azure Cognitive Services endpoint format detected" -ForegroundColor Green
              Write-Host "   This endpoint supports OpenAI API calls at /openai/* paths" -ForegroundColor Green
            } elseif ($env:AZURE_OPENAI_ENDPOINT -match 'https://.*\.openai\.azure\.com/?$') {
              Write-Host "✅ Valid Azure OpenAI endpoint format detected" -ForegroundColor Green
            } else {
              Write-Warning "⚠️  Unexpected endpoint format - tests may still work but verify configuration"
              Write-Host "   Expected: https://<name>.cognitiveservices.azure.com/ or https://<name>.openai.azure.com/" -ForegroundColor Yellow
            }
          }
          Write-Host "===================================" -ForegroundColor Magenta

          # Create test results directory
          New-Item -ItemType Directory -Path "./test-results" -Force | Out-Null

          # Configure Pester
          $config = New-PesterConfiguration
          $config.Run.Path = './src/Tests/Integration/Console.Integration.Tests.ps1'
          $config.Output.Verbosity = 'Detailed'
          $config.TestResult.Enabled = $true
          $config.TestResult.OutputFormat = 'NUnitXml'
          $config.TestResult.OutputPath = './test-results/integration-tests.xml'
          $config.CodeCoverage.Enabled = $false
          $config.Should.ErrorAction = 'Continue'

          try {
            Write-Host "Starting console integration tests..." -ForegroundColor Green
            Write-Host "SQL Server: ${{ inputs.SQL_SERVER_NAME }}" -ForegroundColor Yellow
            Write-Host "Azure AI Foundry Endpoint: ${{ inputs.AZURE_AI_FOUNDRY_ENDPOINT }}" -ForegroundColor Yellow
            Invoke-Pester -Configuration $config
            Write-Host "Integration tests completed" -ForegroundColor Green
          } catch {
            Write-Error "Integration tests failed: $($_.Exception.Message)"
            throw
          }

      - name: Publish Integration Test Results
        uses: dorny/test-reporter@v2
        if: always()
        with:
          name: Console Integration Test Results
          path: './test-results/integration-tests.xml'
          reporter: java-junit

      - name: Upload Integration Test Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: console-integration-test-results
          path: |
            ./test-results/
            ./temp-workspaces/
          retention-days: 7

      - name: Disable Azure AI Foundry Public Access After Tests
        if: always()
        uses: azure/powershell@v2
        with:
          azPSVersion: "latest"
          inlineScript: |
            # Disable public network access for AI Foundry service after tests
            $AIFoundryName = $env:AI_FOUNDRY_NAME
            if ($AIFoundryName) {
              $ResourceGroup = "${{ inputs.RESOURCE_GROUP_NAME }}"
              
              try {
                # Get current configuration
                Write-Host "Checking current network configuration for AI Foundry service: $AIFoundryName"
                $account = Get-AzCognitiveServicesAccount -ResourceGroupName $ResourceGroup -Name $AIFoundryName -ErrorAction Stop
                Write-Host "Current public network access: $($account.Properties.PublicNetworkAccess)"
                Write-Host "Current network ACLs default action: $($account.Properties.NetworkAcls.DefaultAction)"
                
                # Always disable after tests to restore security
                Write-Host "Disabling public network access for AI Foundry service: $AIFoundryName"
                
                # Create a network rule set that denies all access
                $networkRuleSet = New-Object Microsoft.Azure.Commands.Management.CognitiveServices.Models.PSNetworkRuleSet
                $networkRuleSet.DefaultAction = "Deny"
                
                Set-AzCognitiveServicesAccount `
                  -ResourceGroupName $ResourceGroup `
                  -Name $AIFoundryName `
                  -PublicNetworkAccess "Disabled" `
                  -NetworkRuleSet $networkRuleSet `
                  -Force
                
                # Verify the changes took effect
                $updatedAccount = Get-AzCognitiveServicesAccount -ResourceGroupName $ResourceGroup -Name $AIFoundryName
                Write-Host "Updated public network access: $($updatedAccount.Properties.PublicNetworkAccess)"
                Write-Host "Updated network ACLs default action: $($updatedAccount.Properties.NetworkAcls.DefaultAction)"
                
                if ($updatedAccount.Properties.PublicNetworkAccess -eq "Disabled" -and $updatedAccount.Properties.NetworkAcls.DefaultAction -eq "Deny") {
                  Write-Host "✅ Public network access successfully disabled for AI Foundry service" -ForegroundColor Green
                } else {
                  Write-Warning "⚠️  Network access may not have been properly updated."
                  Write-Host "   Expected: PublicNetworkAccess=Disabled, DefaultAction=Deny" -ForegroundColor Yellow
                  Write-Host "   Actual: PublicNetworkAccess=$($updatedAccount.Properties.PublicNetworkAccess), DefaultAction=$($updatedAccount.Properties.NetworkAcls.DefaultAction)" -ForegroundColor Yellow
                }
              }
              catch {
                Write-Warning "Could not find AI Foundry service: $AIFoundryName"
                Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
              }
            }
            else {
              Write-Host "No AI Foundry service name available - skipping public access cleanup"
            }

      - name: Remove SQL Server Firewall Rule
        if: always()
        uses: azure/powershell@v2
        with:
          azPSVersion: "latest"
          inlineScript: |
            # Use the provided resource group and SQL server names
            $ResourceGroup = "${{ inputs.RESOURCE_GROUP_NAME }}"
            $SqlServerName = "${{ inputs.SQL_SERVER_NAME }}"
            $FirewallRuleName = "GitHubRunner-${{ github.run_id }}"
            
            Write-Host "Removing firewall rule for SQL Server: $SqlServerName"
            Write-Host "Resource Group: $ResourceGroup"
            Write-Host "Firewall Rule Name: $FirewallRuleName"
            
            try {
              # Remove the firewall rule
              Remove-AzSqlServerFirewallRule `
                -ResourceGroupName $ResourceGroup `
                -ServerName $SqlServerName `
                -FirewallRuleName $FirewallRuleName `
                -Force
              
              Write-Host "✅ Firewall rule removed successfully" -ForegroundColor Green
            }
            catch {
              # Ignore errors if rule doesn't exist or already removed
              Write-Warning "Firewall rule not found or already removed: $($_.Exception.Message)"
              Write-Host "This is expected if the rule was already cleaned up or never created"
            }
            
            Write-Host "Firewall rule cleanup completed"
